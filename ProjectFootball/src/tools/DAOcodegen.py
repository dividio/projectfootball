# PyDia C++ DAO Code Generation from UML Diagram
# Copyright (c) 2008 Ikaro Games <www.ikarogames.com>
#
# Version: 1.8
#
# Based on PyDia Code Generation from UML Diagram
# Copyright (c) 2005  Hans Breuer <hans@breuer.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


import os, sys, dia
from string import Template

##################################################################################################
# UtilRenderer ###################################################################################
##################################################################################################
class UtilRenderer :
  def license(self) :
    string = "/******************************************************************************\n"+\
             "* Copyright (C) 2008 - Ikaro Games   www.ikarogames.com                       *\n"+\
             "*                                                                             *\n"+\
             "* This program is free software; you can redistribute it and/or               *\n"+\
             "* modify it under the terms of the GNU General Public License                 *\n"+\
             "* as published by the Free Software Foundation; either version 2              *\n"+\
             "* of the License, or (at your option) any later version.                      *\n"+\
             "*                                                                             *\n"+\
             "* This program is distributed in the hope that it will be useful,             *\n"+\
             "* but WITHOUT ANY WARRANTY; without even the implied warranty of              *\n"+\
             "* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *\n"+\
             "* GNU General Public License for more details.                                *\n"+\
             "*                                                                             *\n"+\
             "* You should have received a copy of the GNU General Public License           *\n"+\
             "* along with this program; if not, write to the Free Software                 *\n"+\
             "* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. *\n"+\
             "*                                                                             *\n"+\
             "*                                                                             *\n"+\
             "*       generated by dia/DAOcodegen.py                                        *\n"+\
             "*       Version: 1.8                                                          *\n"+\
             "******************************************************************************/\n\n"
    return string

  def interfaceName(self, cadena) :
    cad = cadena
    cad = cad.lower()
    cad = cad.replace("_", " ")
    cad = cad.title()
    cad = cad.replace(" ", "")
    cad = "I" + cad
    return cad

  def className(self, cadena) :
    cad = cadena
    cad = cad.lower()
    cad = cad.replace("_", " ")
    cad = cad.title()
    cad = cad.replace(" ", "")
    cad = "C" + cad
    return cad

  def attributeName(self, cadena) :
    cad = cadena
    cad = cad.lower()
    cad = cad.replace("_", " ")
    cad = cad.title()
    cad = cad.replace(" ", "")
    return cad

  def defineH(self, cadena) :
    cad = cadena
    cad = cad.upper();
    cad = "#ifndef "+cad+"_H_\n"+\
          "#define "+cad+"_H_\n\n"
    return cad

  def endDefineH(self, cadena) :
    cad = cadena
    cad = cad.upper()
    cad = "#endif /*"+cad+"_H_*/\n"
    return cad

  def primaryKey(self, klass) :
    pk = ""
    for a in klass.attributes.keys() :
      if a[:2]=="X_" and a[:4]!="X_FK" :
        pk = a
    return pk


##################################################################################################
# IDAOFactoryRenderer ############################################################################
##################################################################################################
class IDAOFactoryRenderer(UtilRenderer) :
  def includes(self, klasses) :
    inc = ""
    for klass in klasses.keys() :
      inc = inc+"#include \"../"+self.interfaceName(klass)+"DAO.h\"\n"
    inc = inc+"\n"
    return inc

  def methods(self, klasses) :
    meth = ""
    for klass in klasses.keys() :
      meth = meth+"    virtual "+self.interfaceName(klass)+"DAO* get"+self.interfaceName(klass)+"DAO() =0;\n"
    meth = meth+"\n"
    return meth

  def render(self, path, klasses) :
    file = open(os.path.join(path, "db/dao/factory/IDAOFactory.h"), "w")
    file.write(self.license())
    file.write(self.defineH("IDAOFactory"))
    file.write(self.includes(klasses))
    file.write("class IDAOFactory\n")
    file.write("{\n")
    file.write("public:\n")
    file.write("    IDAOFactory(){}\n")
    file.write("    virtual ~IDAOFactory(){}\n")
    file.write("\n")
    file.write("    virtual bool createSchema() =0;\n")
    file.write("\n")
    file.write(self.methods(klasses))
    file.write("};\n")
    file.write(self.endDefineH("IDAOFactory"))
    file.close()


##################################################################################################
# IClassDAORenderer ##############################################################################
##################################################################################################
class IClassDAORenderer(UtilRenderer) :
  def render(self, path, klass) :
    cClass    = self.className(klass.name)
    iClassDAO = self.interfaceName(klass.name)+"DAO"
    file = open(os.path.join(path, "db/dao/"+iClassDAO+".h"), "w")
    file.write(self.license())
    file.write(self.defineH(iClassDAO))
    file.write("#include <string>\n")
    file.write("#include <vector>\n")
    file.write("\n");
    file.write("#include \"../bean/"+cClass+".h\"\n")
    file.write("\n");
    file.write("class "+iClassDAO+"\n")
    file.write("{\n")
    file.write("public:\n")
    file.write("    "+iClassDAO+"(){}\n")
    file.write("    virtual ~"+iClassDAO+"(){}\n")
    file.write("\n")
    file.write("    virtual bool deleteReg("+cClass+" *reg) =0;\n")
    file.write("    virtual bool insertReg("+cClass+" *reg) =0;\n")
    file.write("    virtual bool updateReg("+cClass+" *reg) =0;\n")
    file.write("\n")
    file.write("    virtual void freeVector(std::vector<"+cClass+"*>* vector) =0;\n")
    file.write("\n")
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if a[:2]=="X_" :
        if t=="TEXT" :
          file.write("    virtual "+cClass+"* findBy"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+") =0;\n")
        elif t=="INTEGER" :
          file.write("    virtual "+cClass+"* findBy"+self.attributeName(a)+"(int "+self.attributeName(a)+") =0;\n")
          file.write("    virtual "+cClass+"* findBy"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+") =0;\n")
        elif t=="DOUBLE" :
          file.write("    virtual "+cClass+"* findBy"+self.attributeName(a)+"(double "+self.attributeName(a)+") =0;\n")
          file.write("    virtual "+cClass+"* findBy"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+") =0;\n")
    file.write("\n")
    file.write("};\n")
    file.write(self.endDefineH(iClassDAO))
    file.close()


##################################################################################################
# CBeanClassRenderer #############################################################################
##################################################################################################
class CBeanClassRenderer(UtilRenderer) :
  def renderGettersH(self, klass) :
    getters = ""
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if t=="TEXT" :
        getters = getters+"    const std::string& get"+self.attributeName(a)+"();\n"
      elif t=="INTEGER" :
        getters = getters+"    int get"+self.attributeName(a)+"_int();\n"
        getters = getters+"    const std::string& get"+self.attributeName(a)+"();\n"
      elif t=="DOUBLE" :
        getters = getters+"    double get"+self.attributeName(a)+"_dbl();\n"
        getters = getters+"    const std::string& get"+self.attributeName(a)+"();\n"
    return getters

  def renderSettersH(self, klass) :
    setters = ""
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if t=="TEXT" :
        setters = setters+"    void set"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+");\n"
      elif t=="INTEGER" :
        setters = setters+"    void set"+self.attributeName(a)+"(int "+self.attributeName(a)+");\n"
        setters = setters+"    void set"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+");\n"
      elif t=="DOUBLE" :
        setters = setters+"    void set"+self.attributeName(a)+"(double "+self.attributeName(a)+");\n"
        setters = setters+"    void set"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+");\n"
    return setters

  def renderAttribsH(self, klass) :
    attribs = ""
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if t=="TEXT" :
        attribs = attribs+"    std::string m_"+self.attributeName(a)+";\n"
      elif t=="INTEGER" :
        attribs = attribs+"    std::string m_"+self.attributeName(a)+";\n"
      elif t=="DOUBLE" :
        attribs = attribs+"    std::string m_"+self.attributeName(a)+";\n"
    return attribs

  def renderH(self, path, klass) :
    cClass = self.className(klass.name)
    file = open(os.path.join(path, "db/bean/"+cClass+".h"), "w")
    file.write(self.license())
    file.write(self.defineH(cClass))
    file.write("#include <string>\n")
    file.write("\n");
    file.write("class "+cClass+"\n")
    file.write("{\n")
    file.write("public:\n")
    file.write("    "+cClass+"();\n")
    file.write("    virtual ~"+cClass+"();\n")
    file.write("\n")
    file.write(self.renderGettersH(klass))
    file.write("\n")
    file.write(self.renderSettersH(klass))
    file.write("\n")
    file.write("private:\n")
    file.write(self.renderAttribsH(klass))
    file.write("\n")
    file.write("};\n")
    file.write(self.endDefineH(cClass))
    file.close()

  def renderConstructorCPP(self, klass) :
    cClass = self.className(klass.name)
    constructor = cClass+"::"+cClass+"()\n"
    constructor = constructor+"{\n"
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if t=="TEXT" :
        constructor = constructor+"    m_"+self.attributeName(a)+" = \"\";\n"
      elif t=="INTEGER" :
        constructor = constructor+"    m_"+self.attributeName(a)+" = \"0\";\n"
      elif t=="DOUBLE" :
        constructor = constructor+"    m_"+self.attributeName(a)+" = \"0.0\";\n"
    constructor = constructor+"}\n\n"
    return constructor

  def renderDestructorCPP(self, klass) :
    cClass = self.className(klass.name)
    destructor = cClass+"::~"+cClass+"()\n"
    destructor = destructor+"{\n"
    destructor = destructor+"}\n\n"
    return destructor

  def renderGettersCPP(self, klass) :
    getters = ""
    cClass  = self.className(klass.name)
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if t=="TEXT" :
        getters = getters+"const std::string& "+cClass+"::get"+self.attributeName(a)+"()\n"
        getters = getters+"{\n"
        getters = getters+"    return m_"+self.attributeName(a)+";\n"
        getters = getters+"}\n\n"
      elif t=="INTEGER" :
        getters = getters+"int "+cClass+"::get"+self.attributeName(a)+"_int()\n"
        getters = getters+"{\n"
        getters = getters+"    return atoi(m_"+self.attributeName(a)+".c_str());\n"
        getters = getters+"}\n\n"
        getters = getters+"const std::string& "+cClass+"::get"+self.attributeName(a)+"()\n"
        getters = getters+"{\n"
        getters = getters+"    return m_"+self.attributeName(a)+";\n"
        getters = getters+"}\n\n"
      elif t=="DOUBLE" :
        getters = getters+"double "+cClass+"::get"+self.attributeName(a)+"_dbl();\n"
        getters = getters+"{\n"
        getters = getters+"    return atog(m_"+self.attributeName(a)+".c_str());\n"
        getters = getters+"}\n\n"
        getters = getters+"const std::string& "+cClass+"::get"+self.attributeName(a)+"()\n"
        getters = getters+"{\n"
        getters = getters+"    return m_"+self.attributeName(a)+";\n"
        getters = getters+"}\n\n"
    return getters

  def renderSettersCPP(self, klass) :
    setters = ""
    cClass  = self.className(klass.name)
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if t=="TEXT" :
        setters = setters+"void "+cClass+"::set"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+")\n"
        setters = setters+"{\n"
        setters = setters+"    m_"+self.attributeName(a)+" = "+self.attributeName(a)+";\n"
        setters = setters+"}\n\n"
      elif t=="INTEGER" :
        setters = setters+"void "+cClass+"::set"+self.attributeName(a)+"(int "+self.attributeName(a)+")\n"
        setters = setters+"{\n"
        setters = setters+"    std::ostringstream stream;\n"
        setters = setters+"    stream << "+self.attributeName(a)+";\n"
        setters = setters+"    m_"+self.attributeName(a)+" = stream.str();\n"
        setters = setters+"}\n\n"
        setters = setters+"void "+cClass+"::set"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+")\n"
        setters = setters+"{\n"
        setters = setters+"    m_"+self.attributeName(a)+" = "+self.attributeName(a)+";\n"
        setters = setters+"}\n\n"
      elif t=="DOUBLE" :
        setters = setters+"void "+cClass+"::set"+self.attributeName(a)+"(double "+self.attributeName(a)+")\n"
        setters = setters+"{\n"
        setters = setters+"    std::ostringstream stream;\n"
        setters = setters+"    stream << "+self.attributeName(a)+";\n"
        setters = setters+"    m_"+self.attributeName(a)+" = stream.str();\n"
        setters = setters+"}\n\n"
        setters = setters+"void "+cClass+"::set"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+")\n"
        setters = setters+"{\n"
        setters = setters+"    m_"+self.attributeName(a)+" = "+self.attributeName(a)+";\n"
        setters = setters+"}\n\n"
    return setters

  def renderCPP(self, path, klass) :
    cClass = self.className(klass.name)
    file = open(os.path.join(path, "db/bean/"+cClass+".cpp"), "w")
    file.write(self.license())
    file.write("#include <iostream>\n")
    file.write("#include <sstream>\n")
    file.write("\n");
    file.write("#include \""+cClass+".h\"\n")
    file.write("\n");
    file.write(self.renderConstructorCPP(klass))
    file.write(self.renderDestructorCPP(klass))
    file.write(self.renderGettersCPP(klass))
    file.write(self.renderSettersCPP(klass))
    file.close()

  def render(self, path, klass) :
    self.renderH(path, klass)
    self.renderCPP(path, klass)


##################################################################################################
# CDAOFactorySQLiteRenderer ######################################################################
##################################################################################################
class CDAOFactorySQLiteRenderer(UtilRenderer) :
  def includesDAO(self, klasses) :
    inc = ""
    for klass in klasses.keys() :
      inc = inc+"#include \"../../../dao/"+self.interfaceName(klass)+"DAO.h\"\n"
    inc = inc+"\n"
    for klass in klasses.keys() :
      inc = inc+"#include \"../"+self.className(klass)+"DAOSQLite.h\"\n"
    inc = inc+"\n"
    return inc

  def methodsH(self, klasses) :
    meth = ""
    for klass in klasses.keys() :
      meth = meth+"    virtual "+self.interfaceName(klass)+"DAO* get"+self.interfaceName(klass)+"DAO();\n"
    meth = meth+"\n"
    return meth

  def renderAttribsH(self, klasses) :
    attribs = ""
    for klass in klasses.keys() :
      attribs = attribs+"    "+self.className(klass)+"DAOSQLite"+" *m_"+self.attributeName(klass)+"DAOSQLite"+";\n"
    return attribs

  def renderH(self, path, klasses) :
    file = open(os.path.join(path, "db/sqlite/dao/factory/CDAOFactorySQLite.h"), "w")
    file.write(self.license())
    file.write(self.defineH("CDAOFactorySQLite"))
    file.write("#include <sqlite3.h>\n")
    file.write("#include <string>\n")
    file.write("\n");
    file.write("#include \"../../../dao/factory/IDAOFactory.h\"\n")
    file.write("\n");
    file.write(self.includesDAO(klasses))
    file.write("class CDAOFactorySQLite : public IDAOFactory\n")
    file.write("{\n")
    file.write("public:\n")
    file.write("    CDAOFactorySQLite(std::string file);\n")
    file.write("    virtual ~CDAOFactorySQLite();\n")
    file.write("\n")
    file.write("    virtual bool createSchema();\n")
    file.write("\n")
    file.write(self.methodsH(klasses))
    file.write("\n")
    file.write("private:\n")
    file.write("    sqlite3 *m_database;\n")
    file.write("\n")
    file.write(self.renderAttribsH(klasses))
    file.write("\n")
    file.write("};\n")
    file.write(self.endDefineH("CDAOFactorySQLite"))
    file.close()

  def renderConstructorCPP(self, klasses) :
    constructor = "CDAOFactorySQLite::CDAOFactorySQLite(std::string file)\n"
    constructor = constructor+"{\n"
    constructor = constructor+"    CLog::getInstance()->info(\"Path: %s\", file.c_str());\n"
    constructor = constructor+"    if( sqlite3_open(file.c_str(), &m_database )!=SQLITE_OK ){\n"
    constructor = constructor+"        sqlite3_close(m_database);\n"
    constructor = constructor+"        m_database = NULL;\n"
    constructor = constructor+"        CLog::getInstance()->exception(\"Can't open database file: \\\"%s\\\" --> \\\"%s\\\"\", file.c_str(), sqlite3_errmsg(m_database));\n"
    constructor = constructor+"    }\n"
    constructor = constructor+"    \n"
    for klass in klasses.keys() :
      constructor = constructor+"    m_"+self.attributeName(klass)+"DAOSQLite = new "+self.className(klass)+"DAOSQLite(m_database);\n"
    constructor = constructor+"    \n"
    constructor = constructor+"    CLog::getInstance()->info(\"SQLite Database open: <-- \\\"%s\\\"\", file.c_str());\n"
    constructor = constructor+"}\n\n"
    return constructor

  def renderDestructorCPP(self, klasses) :
    destructor = "CDAOFactorySQLite::~CDAOFactorySQLite()\n"
    destructor = destructor+"{\n"
    for klass in klasses.keys() :
      destructor = destructor+"    delete m_"+self.attributeName(klass)+"DAOSQLite;\n"
    destructor = destructor+"    \n"
    destructor = destructor+"    sqlite3_close(m_database);\n"
    destructor = destructor+"    CLog::getInstance()->info(\"SQLite Database closed\");\n"
    destructor = destructor+"}\n\n"
    return destructor

  def renderCreateSchemaCPP(self, klasses) :
    create = "bool CDAOFactorySQLite::createSchema()\n"
    create = create+"{\n"
    create = create+"    std::string sql = \"\";\n"
    create = create+"    sql += \"BEGIN TRANSACTION;\";\n"
    for k in klasses.keys() :
      coma      = ""
      klass     = klasses[k]
      tableName = klass.name.upper();
      create = create +"    sql += \"CREATE TABLE "+tableName+"\";\n"
      create = create +"    sql += \"(\";\n"
      for a in klass.attributes.keys() :
        t, v = klass.attributes[a]
        if a[:2]=="X_" and a[:4]!="X_FK" :
          if t=="TEXT" :
            create = create+"    sql += \"  "+coma+a.upper()+" TEXT PRIMARY KEY\";\n"
            coma=","
          elif t=="INTEGER" :
            create = create+"    sql += \"  "+coma+a.upper()+" INTEGER PRIMARY KEY AUTOINCREMENT\";\n"
            coma=","
          elif t=="DOUBLE" :
            create = create+"    sql += \"  "+coma+a.upper()+" REAL PRIMARY KEY\";\n"
            coma=","
        else :
          if t=="TEXT" :
            create = create+"    sql += \"  "+coma+a.upper()+" TEXT\";\n"
            coma=","
          elif t=="INTEGER" :
            create = create+"    sql += \"  "+coma+a.upper()+" INTEGER\";\n"
            coma=","
          elif t=="DOUBLE" :
            create = create+"    sql += \"  "+coma+a.upper()+" REAL\";\n"
            coma=","
      create = create+"    sql += \");\";\n"
    for k in klasses.keys() :
      klass     = klasses[k]
      tableName = klass.name.upper();
      for a in klass.attributes.keys() :
        if a[:2]=="X_" :
          create = create+"    sql += \"CREATE INDEX "+tableName+"_"+a.upper()+" ON "+tableName+" ("+a.upper()+");\";\n"
    create = create+"    sql += \"COMMIT;\";\n\n"
    create = create+"    char *msgError = NULL;\n"
    create = create+"    bool correct = true;\n"
    create = create+"    if( sqlite3_exec(m_database, sql.c_str(), NULL, NULL, &msgError)!=SQLITE_OK ){\n"
    create = create+"        CLog::getInstance()->error(\"Error in SQL: \\\"%s\\\" --> \\\"%s\\\"\", sql.c_str(), msgError);\n"
    create = create+"        sqlite3_free(msgError);\n"
    create = create+"        correct = false;\n"
    create = create+"    }\n"
    create = create+"    return correct;\n"
    create = create+"}\n\n"
    return create

  def renderGettersCPP(self, klasses) :
    getters = ""
    for klass in klasses.keys() :
      getters = getters+self.interfaceName(klass)+"DAO* CDAOFactorySQLite::get"+self.interfaceName(klass)+"DAO()\n"
      getters = getters+"{\n"
      getters = getters+"    return m_"+self.attributeName(klass)+"DAOSQLite;\n"
      getters = getters+"}\n\n"
    return getters

  def renderCPP(self, path, klasses) :
    file = open(os.path.join(path, "db/sqlite/dao/factory/CDAOFactorySQLite.cpp"), "w")
    file.write(self.license())
    file.write("#include \"CDAOFactorySQLite.h\"\n")
    file.write("#include \"../../../../utils/CLog.h\"\n")
    file.write("\n");
    file.write(self.renderConstructorCPP(klasses))
    file.write(self.renderDestructorCPP(klasses))
    file.write(self.renderCreateSchemaCPP(klasses))
    file.write(self.renderGettersCPP(klasses))
    file.close()

  def render(self, path, klasses) :
    self.renderH(path, klasses)
    self.renderCPP(path, klasses)


##################################################################################################
# CClassDAOEntityRenderer ########################################################################
##################################################################################################
class CClassDAOEntityRenderer(UtilRenderer) :
  def renderH(self, path, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    iClassDAO = self.interfaceName(klass.name)+"DAO"
    file = open(os.path.join(path, "db/sqlite/dao/entity/"+cClassDAO+".h"), "w")
    file.write(self.license())
    file.write(self.defineH(cClassDAO))
    file.write("#include <string>\n")
    file.write("#include <vector>\n")
    file.write("#include <sqlite3.h>\n")
    file.write("\n");
    file.write("#include \"../../../bean/"+cClass+".h\"\n")
    file.write("#include \"../../../dao/"+iClassDAO+".h\"\n")
    file.write("\n");
    file.write("class "+cClassDAO+" : public "+iClassDAO+"\n")
    file.write("{\n")
    file.write("public:\n")
    file.write("    "+cClassDAO+"(sqlite3 *database);\n")
    file.write("    virtual ~"+cClassDAO+"();\n")
    file.write("\n")
    file.write("    virtual bool deleteReg("+cClass+" *reg);\n")
    file.write("    virtual bool insertReg("+cClass+" *reg);\n")
    file.write("    virtual bool updateReg("+cClass+" *reg);\n")
    file.write("\n")
    file.write("    virtual void freeVector(std::vector<"+cClass+"*>* vector);\n")
    file.write("\n")
    file.write("protected:\n")
    file.write("    "+cClass+"* loadRegister(std::string sql);\n")
    file.write("    std::vector<"+cClass+"*>* loadVector(std::string sql);\n")
    file.write("\n")
    file.write("private:\n")
    file.write("    bool exec(std::string sql);\n")
    file.write("    static int callbackRegister(void *object, int nColumns, char **vColumn, char **sColumn );\n")
    file.write("    static int callbackVector(void *object, int nColumns, char **vColumn, char **sColumn );\n")
    file.write("\n")
    file.write("    sqlite3 *m_database;\n")
    file.write("\n")
    file.write("};\n")
    file.write(self.endDefineH(cClassDAO))
    file.close()

  def renderConstructorCPP(self, klass) :
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    constructor = cClassDAO+"::"+cClassDAO+"(sqlite3 *database)\n"
    constructor = constructor+"{\n"
    constructor = constructor+"    m_database = database;\n"
    constructor = constructor+"}\n\n"
    return constructor

  def renderDestructorCPP(self, klass) :
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    destructor = cClassDAO+"::~"+cClassDAO+"()\n"
    destructor = destructor+"{\n"
    destructor = destructor+"}\n\n"
    return destructor

  def renderDeleteRegCPP(self, klass) :
    pk        = self.primaryKey(klass)
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    delete = "bool "+cClassDAO+"::deleteReg("+cClass+" *reg)\n"
    delete = delete+"{\n"
    t, v = klass.attributes[pk]
    if t=="TEXT" :
      delete = delete+"    std::string sql(\"DELETE FROM "+klass.name+" WHERE "+pk+"=\");\n"
      delete = delete+"    sql = sql+\"'\"+reg->get"+self.attributeName(pk)+"()+\"'\";\n"
      delete = delete+"    return exec(sql);\n"
    elif t=="INTEGER" :
      delete = delete+"    std::string sql(\"DELETE FROM "+klass.name+" WHERE "+pk+"=\");\n"
      delete = delete+"    sql = sql+\"'\"+reg->get"+self.attributeName(pk)+"()+\"'\";\n"
      delete = delete+"    return exec(sql);\n"
    elif t=="DOUBLE" :
      delete = delete+"    std::string sql(\"DELETE FROM "+klass.name+" WHERE "+pk+"=\");\n"
      delete = delete+"    sql = sql+\"'\"+reg->get"+self.attributeName(pk)+"()+\"'\";\n"
      delete = delete+"    return exec(sql);\n"
    delete = delete+"}\n\n"
    return delete

  def renderInsertRegCPP(self, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    insert = "bool "+cClassDAO+"::insertReg("+cClass+" *reg)\n"
    insert = insert+"{\n"
    insert = insert+"    std::string sql(\"INSERT INTO "+klass.name+" ("
    coma = ""
    for a in klass.attributes.keys() :
      if a[:2]!="X_" or a[:4]=="X_FK" :
        insert = insert+coma+a
        coma=","
    insert = insert+") VALUES (\");\n"
    coma = " "
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if a[:2]!="X_" or a[:4]=="X_FK" :
        if t=="TEXT" :
          insert = insert+"    sql = sql+\""+coma+"'\"+reg->get"+self.attributeName(a)+"()+\"'\";\n"
          coma = ","
        elif t=="INTEGER" :
          insert = insert+"    sql = sql+\""+coma+"'\"+reg->get"+self.attributeName(a)+"()+\"'\";\n"
          coma = ","
        elif t=="DOUBLE" :
          insert = insert+"    sql = sql+\""+coma+"'\"+reg->get"+self.attributeName(a)+"()+\"'\";\n"
          coma = ","
    insert = insert+"    sql = sql+\")\";\n"
    insert = insert+"    return exec(sql);\n"
    insert = insert+"}\n\n"
    return insert

  def renderUpdateRegCPP(self, klass) :
    pk        = self.primaryKey(klass)
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    update = "bool "+cClassDAO+"::updateReg("+cClass+" *reg)\n"
    update = update+"{\n"
    update = update+"    std::string sql(\"UPDATE "+klass.name+" SET \");\n"
    coma = " "
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if t=="TEXT" :
        update = update+"    sql = sql+\""+coma+a+"='\"+reg->get"+self.attributeName(a)+"()+\"'\";\n"
      elif t=="INTEGER" :
        update = update+"    sql = sql+\""+coma+a+"='\"+reg->get"+self.attributeName(a)+"()+\"'\";\n"
      elif t=="DOUBLE" :
        update = update+"    sql = sql+\""+coma+a+"='\"+reg->get"+self.attributeName(a)+"()+\"'\";\n"
      coma = ","
    t, v = klass.attributes[pk]
    if t=="TEXT" :
      update = update+"    sql = sql+\" WHERE "+pk+"='\"+reg->get"+self.attributeName(pk)+"()+\"'\";\n"
    elif t=="INTEGER" :
      update = update+"    sql = sql+\" WHERE "+pk+"='\"+reg->get"+self.attributeName(pk)+"()+\"'\";\n"
    elif t=="DOUBLE" :
      update = update+"    sql = sql+\" WHERE "+pk+"='\"+reg->get"+self.attributeName(pk)+"()+\"'\";\n"
    update = update+"    return exec(sql);\n"
    update = update+"}\n\n"
    return update

  def renderFreeVectorCPP(self, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    fVector = "void "+cClassDAO+"::freeVector(std::vector<"+cClass+"*>* vector )\n"
    fVector = fVector+"{\n"
    fVector = fVector+"    std::vector<"+cClass+"*>::iterator it;\n"
    fVector = fVector+"    for( it=vector->begin(); it!=vector->end(); it++ ){\n"
    fVector = fVector+"        delete (*it);\n"
    fVector = fVector+"        (*it) = NULL;\n"
    fVector = fVector+"    }\n"
    fVector = fVector+"    delete vector;\n"
    fVector = fVector+"}\n\n"
    return fVector

  def renderLoadRegisterCPP(self, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    lRegister = cClass+"* "+cClassDAO+"::loadRegister(std::string sql)\n"
    lRegister = lRegister+"{\n"
    lRegister = lRegister+"    char *msgError = NULL;\n"
    lRegister = lRegister+"    "+cClass+" *destiny = new "+cClass+"();\n"
    lRegister = lRegister+"    if( sqlite3_exec(m_database, sql.c_str(), callbackRegister, destiny, &msgError)!=SQLITE_OK ){\n"
    lRegister = lRegister+"        CLog::getInstance()->error(\"Error in SQL: \\\"%s\\\" --> \\\"%s\\\"\", sql.c_str(), msgError);\n"
    lRegister = lRegister+"        sqlite3_free(msgError);\n"
    lRegister = lRegister+"    }\n"
    lRegister = lRegister+"    return destiny;\n"
    lRegister = lRegister+"}\n\n"
    return lRegister

  def renderLoadVectorCPP(self, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    lVector = "std::vector<"+cClass+"*> * "+cClassDAO+"::loadVector(std::string sql)\n"
    lVector = lVector+"{\n"
    lVector = lVector+"    char *msgError = NULL;\n"
    lVector = lVector+"    std::vector<"+cClass+"*> *container = new std::vector<"+cClass+"*>;\n"
    lVector = lVector+"    if( sqlite3_exec(m_database, sql.c_str(), callbackVector, container, &msgError)!=SQLITE_OK ){\n"
    lVector = lVector+"        CLog::getInstance()->error(\"Error in SQL: \\\"%s\\\" --> \\\"%s\\\"\", sql.c_str(), msgError);\n"
    lVector = lVector+"        sqlite3_free(msgError);\n"
    lVector = lVector+"    }\n"
    lVector = lVector+"    return container;\n"
    lVector = lVector+"}\n\n"
    return lVector

  def renderExecCPP(self, klass) :
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    ex = "bool "+cClassDAO+"::exec(std::string sql)\n"
    ex = ex+"{\n"
    ex = ex+"    char *msgError = NULL;\n"
    ex = ex+"    bool correct = true;\n"
    ex = ex+"    if( sqlite3_exec(m_database, sql.c_str(), NULL, NULL, &msgError)!=SQLITE_OK ){\n"
    ex = ex+"        CLog::getInstance()->error(\"Error in SQL: \\\"%s\\\" --> \\\"%s\\\"\", sql.c_str(), msgError);\n"
    ex = ex+"        sqlite3_free(msgError);\n"
    ex = ex+"        correct = false;\n"
    ex = ex+"    }\n"
    ex = ex+"    return correct;\n"
    ex = ex+"}\n\n"
    return ex

  def renderCallbackRegisterCPP(self, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    cbRegister = "int "+cClassDAO+"::callbackRegister(void *object, int nColumns, char **vColumn, char **sColumn)\n"
    cbRegister = cbRegister+"{\n"
    cbRegister = cbRegister+"    int error = 1;\n"
    cbRegister = cbRegister+"    if( object!=NULL ){\n"
    cbRegister = cbRegister+"        "+cClass+" *destiny = ("+cClass+"*)object;\n"
    cbRegister = cbRegister+"        for( int i=0; i<nColumns; i++ ){\n"
    elseif = ""
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if t=="TEXT" :
        cbRegister = cbRegister+"            "+elseif+"if( strcmp(sColumn[i], \""+a+"\")==0 ){\n"
        cbRegister = cbRegister+"                destiny->set"+self.attributeName(a)+"(vColumn[i]);\n"
      elif t=="INTEGER" :
        cbRegister = cbRegister+"            "+elseif+"if( strcmp(sColumn[i], \""+a+"\")==0 ){\n"
        cbRegister = cbRegister+"                destiny->set"+self.attributeName(a)+"(vColumn[i]);\n"
      elif t=="DOUBLE" :
        cbRegister = cbRegister+"            "+elseif+"if( strcmp(sColumn[i], \""+a+"\")==0 ){\n"
        cbRegister = cbRegister+"                destiny->set"+self.attributeName(a)+"(vColumn[i]);\n"
      elseif = "}else "
    cbRegister = cbRegister+"            }\n"
    cbRegister = cbRegister+"        }\n"
    cbRegister = cbRegister+"        error = 0; // All OK\n"
    cbRegister = cbRegister+"    }\n"
    cbRegister = cbRegister+"    return error;\n"
    cbRegister = cbRegister+"}\n\n"
    return cbRegister

  def renderCallbackVectorCPP(self, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    cbVector = "int "+cClassDAO+"::callbackVector(void *object, int nColumns, char **vColumn, char **sColumn)\n"
    cbVector = cbVector+"{\n"
    cbVector = cbVector+"    if( object!=NULL ){\n"
    cbVector = cbVector+"        std::vector<"+cClass+"*> *container = (std::vector<"+cClass+"*> *)object;\n"
    cbVector = cbVector+"        "+cClass+" *destiny = new "+cClass+"();\n"
    cbVector = cbVector+"        for( int i=0; i<nColumns; i++ ){\n"
    elseif = ""
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if t=="TEXT" :
        cbVector = cbVector+"            "+elseif+"if( strcmp(sColumn[i], \""+a+"\")==0 ){\n"
        cbVector = cbVector+"                destiny->set"+self.attributeName(a)+"(vColumn[i]);\n"
      elif t=="INTEGER" :
        cbVector = cbVector+"            "+elseif+"if( strcmp(sColumn[i], \""+a+"\")==0 ){\n"
        cbVector = cbVector+"                destiny->set"+self.attributeName(a)+"(vColumn[i]);\n"
      elif t=="DOUBLE" :
        cbVector = cbVector+"            "+elseif+"if( strcmp(sColumn[i], \""+a+"\")==0 ){\n"
        cbVector = cbVector+"                destiny->set"+self.attributeName(a)+"(vColumn[i]);\n"
      elseif = "}else "
    cbVector = cbVector+"            }\n"
    cbVector = cbVector+"        }\n"
    cbVector = cbVector+"        container->push_back(destiny);\n"
    cbVector = cbVector+"    }\n"
    cbVector = cbVector+"    return 0; // All OK\n"
    cbVector = cbVector+"}\n\n"
    return cbVector

  def renderCPP(self, path, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLiteEntity"
    iClassDAO = self.interfaceName(klass.name)+"DAO"
    file = open(os.path.join(path, "db/sqlite/dao/entity/"+cClassDAO+".cpp"), "w")
    file.write(self.license())
    file.write("#include <stdlib.h>\n")
    file.write("\n");
    file.write("#include \""+cClassDAO+".h\"\n")
    file.write("#include \"../../../../utils/CLog.h\"\n")
    file.write("\n");
    file.write(self.renderConstructorCPP(klass))
    file.write(self.renderDestructorCPP(klass))
    file.write(self.renderDeleteRegCPP(klass))
    file.write(self.renderInsertRegCPP(klass))
    file.write(self.renderUpdateRegCPP(klass))
    file.write(self.renderFreeVectorCPP(klass))
    file.write(self.renderLoadRegisterCPP(klass))
    file.write(self.renderLoadVectorCPP(klass))
    file.write(self.renderExecCPP(klass))
    file.write(self.renderCallbackRegisterCPP(klass))
    file.write(self.renderCallbackVectorCPP(klass))
    file.close()

  def render(self, path, klass) :
    self.renderH(path, klass)
    self.renderCPP(path, klass)


##################################################################################################
# CClassDAORenderer ##############################################################################
##################################################################################################
class CClassDAORenderer(UtilRenderer) :
  def renderH(self, path, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLite"
    file = open(os.path.join(path, "db/sqlite/dao/"+cClassDAO+".h"), "w")
    file.write(self.license())
    file.write(self.defineH(cClassDAO))
    file.write("#include <string>\n")
    file.write("#include <sqlite3.h>\n")
    file.write("\n");
    file.write("#include \"entity/"+cClassDAO+"Entity.h\"\n")
    file.write("#include \"../../bean/"+cClass+".h\"\n")
    file.write("\n");
    file.write("class "+cClassDAO+" : public "+cClassDAO+"Entity\n")
    file.write("{\n")
    file.write("public:\n")
    file.write("    "+cClassDAO+"(sqlite3 *database);\n")
    file.write("    virtual ~"+cClassDAO+"();\n")
    file.write("\n")
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if a[:2]=="X_" :
        if t=="TEXT" :
          file.write("    virtual "+cClass+"* findBy"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+");\n")
        elif t=="INTEGER" :
          file.write("    virtual "+cClass+"* findBy"+self.attributeName(a)+"(int "+self.attributeName(a)+");\n")
          file.write("    virtual "+cClass+"* findBy"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+");\n")
        elif t=="DOUBLE" :
          file.write("    virtual "+cClass+"* findBy"+self.attributeName(a)+"(double "+self.attributeName(a)+");\n")
          file.write("    virtual "+cClass+"* findBy"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+");\n")
    file.write("\n")
    file.write("};\n")
    file.write(self.endDefineH(cClassDAO))
    file.close()

  def renderConstructorCPP(self, klass) :
    cClassDAO = self.className(klass.name)+"DAOSQLite"
    constructor = cClassDAO+"::"+cClassDAO+"(sqlite3 *database)\n"
    constructor = constructor+"  : "+cClassDAO+"Entity(database)\n"
    constructor = constructor+"{\n"
    constructor = constructor+"}\n\n"
    return constructor

  def renderDestructorCPP(self, klass) :
    cClassDAO = self.className(klass.name)+"DAOSQLite"
    destructor = cClassDAO+"::~"+cClassDAO+"()\n"
    destructor = destructor+"{\n"
    destructor = destructor+"}\n\n"
    return destructor

  def renderFindMethodsCPP(self, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLite"
    find = ""
    for a in klass.attributes.keys() :
      t, v = klass.attributes[a]
      if a[:2]=="X_" :
        if t=="TEXT" :
          find = find+cClass+"* "+cClassDAO+"::findBy"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+")\n"
          find = find+"{\n"
          find = find+"    std::string sql(\"SELECT * FROM PF_EQUIPOS WHERE \");\n"
          find = find+"    sql = sql+\""+a+"='\"+"+self.attributeName(a)+"+\"'\";\n"
          find = find+"    return loadRegister(sql);\n"
          find = find+"}\n\n"
        elif t=="INTEGER" :
          find = find+cClass+"* "+cClassDAO+"::findBy"+self.attributeName(a)+"(int "+self.attributeName(a)+")\n"
          find = find+"{\n"
          find = find+"    std::ostringstream stream;\n"
          find = find+"    stream << "+self.attributeName(a)+";\n"
          find = find+"    return findBy"+self.attributeName(a)+"(stream.str());\n"
          find = find+"}\n\n"
          find = find+cClass+"* "+cClassDAO+"::findBy"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+")\n"
          find = find+"{\n"
          find = find+"    std::string sql(\"SELECT * FROM PF_EQUIPOS WHERE \");\n"
          find = find+"    sql = sql+\""+a+"='\"+"+self.attributeName(a)+"+\"'\";\n"
          find = find+"    return loadRegister(sql);\n"
          find = find+"}\n\n"
        elif t=="DOUBLE" :
          find = find+cClass+"* "+cClassDAO+"::findBy"+self.attributeName(a)+"(double "+self.attributeName(a)+")\n"
          find = find+"{\n"
          find = find+"    std::ostringstream stream;\n"
          find = find+"    stream << "+self.attributeName(a)+";\n"
          find = find+"    return findBy"+self.attributeName(a)+"(stream.str());\n"
          find = find+"}\n\n"
          find = find+cClass+"* "+cClassDAO+"::findBy"+self.attributeName(a)+"(const std::string &"+self.attributeName(a)+")\n"
          find = find+"{\n"
          find = find+"    std::string sql(\"SELECT * FROM PF_EQUIPOS WHERE \");\n"
          find = find+"    sql = sql+\""+a+"='\"+"+self.attributeName(a)+"+\"'\";\n"
          find = find+"    return loadRegister(sql);\n"
          find = find+"}\n\n"
    return find

  def renderCPP(self, path, klass) :
    cClass    = self.className(klass.name)
    cClassDAO = self.className(klass.name)+"DAOSQLite"
    file = open(os.path.join(path, "db/sqlite/dao/"+cClassDAO+".cpp"), "w")
    file.write(self.license())
    file.write("#include <iostream>\n")
    file.write("#include <sstream>\n")
    file.write("\n");
    file.write("#include \""+cClassDAO+".h\"\n")
    file.write("\n");
    file.write(self.renderConstructorCPP(klass))
    file.write(self.renderDestructorCPP(klass))
    file.write(self.renderFindMethodsCPP(klass))
    file.close()

  def render(self, path, klass) :
    self.renderH(path, klass)
    self.renderCPP(path, klass)


##################################################################################################
# CSQLiteDDLRenderer #############################################################################
##################################################################################################
class CSQLiteDDLRenderer(UtilRenderer) :
  def renderTables(self, path, klasses) :
    file = open(os.path.join(path, "ddl/sqlite/tables.sql"), "w")
    file.write("BEGIN TRANSACTION;\n\n")
    for k in klasses.keys() :
      coma      = ""
      klass     = klasses[k]
      tableName = klass.name.upper();
      file.write("CREATE TABLE "+tableName+"\n")
      file.write("(\n")
      for a in klass.attributes.keys() :
        t, v = klass.attributes[a]
        if a[:2]=="X_" and a[:4]!="X_FK" :
          if t=="TEXT" :
            file.write("  "+coma+a.upper()+" TEXT PRIMARY KEY\n")
            coma=","
          elif t=="INTEGER" :
            file.write("  "+coma+a.upper()+" INTEGER PRIMARY KEY AUTOINCREMENT\n")
            coma=","
          elif t=="DOUBLE" :
            file.write("  "+coma+a.upper()+" REAL PRIMARY KEY\n")
            coma=","
        else :
          if t=="TEXT" :
            file.write("  "+coma+a.upper()+" TEXT\n")
            coma=","
          elif t=="INTEGER" :
            file.write("  "+coma+a.upper()+" INTEGER\n")
            coma=","
          elif t=="DOUBLE" :
            file.write("  "+coma+a.upper()+" REAL\n")
            coma=","
      file.write(");\n\n")
    file.write("COMMIT;\n")

  def renderIndexes(self, path, klasses) :
    file = open(os.path.join(path, "ddl/sqlite/indexes.sql"), "w")
    file.write("BEGIN TRANSACTION;\n")
    for k in klasses.keys() :
      klass     = klasses[k]
      tableName = klass.name.upper();
      for a in klass.attributes.keys() :
        if a[:2]=="X_" :
          file.write("CREATE INDEX "+tableName+"_"+a.upper()+" ON "+tableName+" ("+a.upper()+");\n")
    file.write("COMMIT;\n")

  def render(self, path, klasses) :
    self.renderTables(path, klasses)
    self.renderIndexes(path, klasses)


##################################################################################################
# Klass ##########################################################################################
##################################################################################################
class Klass :
  def __init__ (self, name) :
    self.name = name
    self.attributes = {}
    self.operations = {}
    self.comment = ""
  def AddAttribute(self, name, type, visibility) :
    self.attributes[name] = (type, visibility)
  def AddOperation(self, name, type, visibility, params) :
    self.operations[name] = (type, visibility, params)
  def SetComment(self, s) :
    self.comment = s


##################################################################################################
# DAORenderer ####################################################################################
##################################################################################################
class DAORenderer :
  "Implements the Object Renderer Interface and transforms diagram into its internal representation"
  def __init__ (self) :
    # an empty dictionary of classes
    self.klasses = {}
    self.filename = ""
    self.path = ""
    self.name = ""
    self.ext = ""

  def createDirectories(self) :
    try:
      os.makedirs(self.path+"/db/bean")
      os.makedirs(self.path+"/db/dao/factory")
      os.makedirs(self.path+"/db/sqlite/dao/entity")
      os.makedirs(self.path+"/db/sqlite/dao/factory")
      os.makedirs(self.path+"/ddl/sqlite")
    except:
#      dia.message("Directories already exists")
      print "Directories already exists"

  def parseData(self, data) :
    for layer in data.layers :
      # for the moment ignore layer info. But we could use this to spread accross different files
      for o in layer.objects :
        if o.type.name == "UML - Class" :
          #print o.properties["name"].value
          k = Klass (o.properties["name"].value)
          k.SetComment(o.properties["comment"].value)
          for op in o.properties["operations"].value :
            # op : a tuple with fixed placing, see: objects/UML/umloperations.c:umloperation_props
            # (name, type, comment, stereotype, visibility, inheritance_type, class_scope, params)
            params = []
            for par in op[8] :
              # par : again fixed placement, see objects/UML/umlparameter.c:umlparameter_props
              params.append((par[0], par[1]))
            k.AddOperation (op[0], op[1], op[4], params)
          #print o.properties["attributes"].value
          for attr in o.properties["attributes"].value :
            # see objects/UML/umlattributes.c:umlattribute_props
            #print "\t", attr[0], attr[1], attr[4]
            k.AddAttribute(attr[0], attr[1], attr[4])
          self.klasses[o.properties["name"].value] = k
        elif o.type.name == "UML - Generalization" :
          # could setup inheritance here
          pass
        elif o.type.name == "UML - Association" :
          # should already have got attributes relation by names
          pass
        # other UML objects which may be interesting
        # UML - Note, UML - LargePackage, UML - SmallPackage, UML - Dependency, ...

  def begin_render(self, data, filename) :
    self.filename = filename
    self.path     = os.path.dirname(filename)
    (self.name, self.ext) = os.path.splitext(os.path.basename(self.filename))

    self.parseData(data)
    self.createDirectories()

    IDAOFactoryRenderer().render(self.path, self.klasses)
    CDAOFactorySQLiteRenderer().render(self.path, self.klasses)

    for klass in self.klasses.keys() :
      IClassDAORenderer().render(self.path, self.klasses[klass])
      CBeanClassRenderer().render(self.path, self.klasses[klass])
      CClassDAOEntityRenderer().render(self.path, self.klasses[klass])
      CClassDAORenderer().render(self.path, self.klasses[klass])

    CSQLiteDDLRenderer().render(self.path, self.klasses)

  def end_render(self) :
    # without this we would accumulate info from every pass
    self.attributes = {}
    self.operations = {}


# dia-python keeps a reference to the renderer class and uses it on demand
dia.register_export ("PyDia Code Generation (C++ DAO)", "cpp", DAORenderer())
